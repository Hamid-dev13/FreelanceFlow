generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Énumérations existantes
enum Role {
  DEVELOPER
  PROJECT_MANAGER
}

enum MissionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Nouvelle énumération pour la difficulté
enum MissionDifficulty {
  EASY
  MEDIUM
  HARD
}

model User {
  id        String    @id @default(uuid())
  email     String    @unique
  password  String
  role      Role      @default(DEVELOPER)
  name      String
  clients   Client[]
  projects  Project[]
  missions  Mission[] @relation("AssignedMissions")
  createdMissions Mission[] @relation("CreatedMissions")
  
  // Nouvelles relations pour le système d'évaluation
  experience DevExperience?
  evaluationsReceived MissionEvaluation[] @relation("ReceivedEvaluations")
  evaluationsGiven MissionEvaluation[] @relation("GivenEvaluations")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Client {
  id        String    @id @default(uuid())
  name      String
  email     String
  phone     String?
  user      User      @relation(fields: [userId], references: [id])
  userId    String
  projects  Project[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

model Project {
  id          String    @id @default(uuid())
  title       String
  description String?   @db.Text
  startDate   DateTime  @default(now())
  endDate     DateTime?
  status      String    @default("EN_COURS")
  client      Client    @relation(fields: [clientId], references: [id], onDelete: Cascade)
  clientId    String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  missions    Mission[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model Mission {
  id          String           @id @default(uuid())
  title       String
  description String?          @db.Text
  status      MissionStatus    @default(PENDING)
  deadline    DateTime
  // Nouveau champ
  difficulty  MissionDifficulty @default(MEDIUM)
  
  project     Project?         @relation(fields: [projectId], references: [id])
  projectId   String?

  assignedTo  User?           @relation("AssignedMissions", fields: [assignedToId], references: [id])
  assignedToId String?

  createdBy   User            @relation("CreatedMissions", fields: [createdById], references: [id])
  createdById String

  // Nouvelle relation
  evaluation  MissionEvaluation?

  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
}

// Nouveau modèle pour les évaluations
model MissionEvaluation {
  id          String    @id @default(uuid())
  
  mission     Mission   @relation(fields: [missionId], references: [id])
  missionId   String    @unique  // Une mission ne peut avoir qu'une évaluation
  
  developer   User      @relation("ReceivedEvaluations", fields: [developerId], references: [id])
  developerId String
  
  evaluator   User      @relation("GivenEvaluations", fields: [evaluatorId], references: [id])
  evaluatorId String

  // Critères d'évaluation
  codeQuality Int       // 1-5
  deadline    Int       // 1-5
  autonomy    Int       // 1-5

  // XP gagnée
  xpEarned    Int

  // Technologies utilisées
  technologies String[]

  comment     String?   @db.Text
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

// Nouveau modèle pour l'expérience
model DevExperience {
  id          String    @id @default(uuid())
  
  user        User      @relation(fields: [userId], references: [id])
  userId      String    @unique  // Un dev ne peut avoir qu'une expérience
  
  totalXp     Int       @default(0)
  level       Int       @default(1)
  
  // JSON pour stocker l'XP par technologie
  // Format: { "react": { "xp": 100, "level": 2 }, "node": { "xp": 150, "level": 3 } }
  techExperience Json
  
  // Tableau des badges obtenus
  badges      String[]
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}